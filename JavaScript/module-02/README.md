## 一、ES新特性
### 1. ECMAScript概述
- ECMAScript通常看作JavaScript的标准化规范
- 实际上JavaScript是ECMAScript（只是提供了基本的语法）的扩展语言
- web环境的JavaScript = ECMAScript + BOM + DOM
- node环境的JavaScript = ECMAScript + node本身提供的api
### 2.ES2015let和块级用域
let声明不会提升
### 3. Const
常量 不可修改内存指向地址
### 4. 数组的解构
[]
`const [,,w] = [100, 300, 900]`
### 5. 对象的解构
{}
### 6. 字符串模板
``
带标签的模板字符串
### 7. 字符串扩展方法
startWith()
includes()
### 8. 参数默认值
### 9. 剩余参数
...args
### 10. 扩展运算符
...
### 11. 箭头函数
不会改变this指向; 箭头函数外面的this是什么，里面就是什么
### 12. 对象字面量的增强
计算属性名
### 13.对象的方法
+ Object.assign() 浅copy
+ Object.is 同值比较
### 14.Proxy
监视对象的读写过程
### 15.Proxy和defineProperty
+ Proxy可以监听到删除等等
+ 数组监视 重写数组方法
+ Proxy是以非侵入的方式监管对象的读写
### 16.Reflect - 内部封装了对对象的底层操作
### 17.Promise
### 18.类
class
### 19.static - 静态方法
### 类的继承
extends
### 20.Set数据结构 - 集合
内部的成员不允许重复
Array.from() es6从一个类似数组或可迭代对象创建一个新的数组
```
const arr = [1, 3, 4]
const result = Array.from(new Set(arr))
```
### 21.Map数据结构 - 对象
键可以使用任意类型(之前对象的键会被转化成字符串)
### 22.Symbol
表示一个独一无二的值
`const name = Symbol()`
`for...in`、`Object.keys()`、`JSON.stringify()`无法获取Symbol类型的键值，使用`Object.getOwnPropertySymbols(obj)`可获取到
### 23.for...of
- 遍历所有数据结构的统一方式
- 实现Iterable接口才可以遍历
### 24.迭代器模式
### 25.生成器函数
减少回调函数嵌套，会自动返回生成器对象，调用next方法就执行，遇到yield会暂停执行。

## 二、TypeScript
### 1.强类型与弱类型
强类型： 不允许随意的隐式类型转换

弱类型：相反
### 2.静态类型与动态类型
静态类型：一个变量声明时它的类型就是明确的，声明过后不允许修改

动态类型： 变量没有类型，变量中存放的值有类型
### 3.强类型语言的优势
- 错误更早暴露
- 代码更智能，编码更准确
- 重构更牢靠
- 减少不必要的类型判断
### 4.Flow概述
JavaScript的类型检查器

## 三、性能优化
### 1. 内存管理
- 内存：由可读写单元组成，表示一片可操作空间
- 管理：人为的去操作一片空间的申请、使用和释放
- 内存管理：开发者主动申请空间、使用空间、释放空间
### 2. JavaScript垃圾回收
#### 2.1 什么是垃圾
- JavaScript内存管理是自动的
- 对象不再被`引用`时是垃圾
- 对象不能`从跟上访问`到时是垃圾
#### 2.2 JavaScript中的可达对象
- 可以访问到的对象就是可达对象（引用、作用域）
- 可达的标准就是从跟上触发是否能够被找到
- JavaScript中的跟就可以理解为师全局变量的对象

### 3. GC算法
- GC是一种机制，垃圾回收器完成具体工作
- 工作的内容就是查找垃圾释放空间、回收空间
- 算法就是工作时查找和回收所遵循的规则
#### 3.1 常见GC算法
- 引用计数算法
- 标记清除算法
- 标记整理算法
### 4. 引用计数算法优缺点
- 优点：发现垃圾时立即回收；减少程序卡顿；
- 缺点：无法回收循环引用的对象；资源消耗大（频繁操作计数器）
### 5. 标记清除算法
- 核心思想 标记活动对象
- 遍历标记
- 清除没有标记的对象
### 6. 标记清除算法优缺点
- 优点：解决循环引用不能清除的问题
- 缺点：空间碎片化
### 7. 标记整理算法
- 标记清除的增强
- 清除之前整理
### 8. V8引擎
- JavaScript执行引擎
- 采用即时编译
- 内存设限
### 9. V8垃圾回收策略
- 采用分代回收思想
- 内存分为新生代、老生代
- 常用算法：.....
### 10. 新生代对象回收实现
- 新生代内存区分为两个等大小空间
### 11. 内存问题标准
- 内存泄漏：内存使用持续升高
- 内存膨胀：在多个设备上都存在
- 频繁垃圾回收
### 12. Timeline记录内存
### 13. 堆快照查找分离DOM
Detached查找分离DOM
### 14. 判断是否存在频繁垃圾回收
- Timeline中频繁的上升下降
- 任务管理器中数据频繁的增加减小
### 15. Performance总结


### 16. V8引擎
- 词法分析
- 语法分析（得到语法树）
- 预解析、解析
- 编译
### 17. 堆栈操作
- JS执行环境
- 执行环境栈
- 执行上下文（管理执行区） EC(G)
- VO(G)，全局变量对象
- GO: 全局对象（并不是VO,但是它是一个对象，因此它也会有一个内存地址）
- 因为有地址就可以对其进行访问JS会在VO(g)当中


基本数据类型是按值进行操作；基本数据类型值存放在 栈区；无论当前的栈内存，还是引用数据类型会使用堆内存；


引用类型会把地址存放到栈区


### 18. 引用类型堆栈处理

### 19. 函数堆栈处理
#### 19.1 函数创建
- 创建函数和创建变量类似 函数名可以看成是一个变量，存放在VO中
- 函数本身也是一个对象，创建时会有一个内存地址，空间内存放的就是函数体代码（字符串形式）
#### 19.2 函数执行
- 函数执行时会形成一个全新私有上下文，它里面有一个AO，用于管理这个上下文当中的变量
#### 19.3 函数执行步骤
- 作用域链（当前执行上下文，上级作用域所在的执行上下文）
- 确定this
- 初始化arguments（对象）
- 行参赋值：他就相当于是变量声明，然后将声明的变量放置于AO
- 变量提升
- 代码执行
### 20. 闭包堆栈处理
- 闭包是一种机制，保护当前上下文当中的变量与其他上下文中变量互不干扰；保存当前上下文数据（堆内存）被当前上下文以外的上下文中的变量所引用，这个数据就保存下来了。
- 函数调用形成了一个全新的私有上下文，在函数调用之后当前上下文不被释放就是闭包

### 21. 变量局部化
建议变量放在同级作用域
### 22. 缓存数据
对于多次使用的数据进行提前保存，后续进行使用

### 23. 较少层级访问
### 24. 防抖和节流
- 在一些高频率事件触发的常场景下不希望对应的事件处理函数多次执行
- 场景：滚动事件、输入模糊匹配、轮播图切换、点击操作
#### 24.1 防抖
- 对于高频的操作来说，只识别一次点击
- 定时器解决
#### 24.2 节流
对于高频的操作，可以自己设置频率

### 25. 减少层级判断
提前返回
### 26. 减少循环体活动
循环体内每次不变的 放到外面





